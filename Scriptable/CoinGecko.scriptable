{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "green",
    "glyph" : "frog"
  },
  "name" : "CoinGecko",
  "script" : "\/**\n * 在 App 内运行时会请求最新的货币列表并缓存\n * \n * 其他情况优先使用缓存中货币 ID 去请求数据\n *\n * @version 1.2.0\n * @author Honye\n *\/\n\nconst getImage = async (url) => {\n  const request = new Request(url);\n  const image = await request.loadImage();\n  return image\n};\n\nconst useCache$1 = () => {\n  const fm = FileManager.local();\n  const cacheDirectory = fm.joinPath(fm.cacheDirectory(), `${Script.name()}.Scriptable`);\n  \/**\n   * 删除路径末尾所有的 \/\n   * @param {string} filePath\n   *\/\n  const safePath = (filePath) => {\n    return fm.joinPath(cacheDirectory, filePath).replace(\/\\\/+$\/, '')\n  };\n  \/**\n   * 如果上级文件夹不存在，则先创建文件夹\n   * @param {string} filePath\n   *\/\n  const preWrite = (filePath) => {\n    const i = filePath.lastIndexOf('\/');\n    const directory = filePath.substring(0, i);\n    if (!fm.fileExists(directory)) {\n      fm.createDirectory(directory, true);\n    }\n  };\n\n  const writeString = (filePath, content) => {\n    const nextPath = safePath(filePath);\n    preWrite(nextPath);\n    fm.writeString(nextPath, content);\n  };\n\n  const writeJSON = (filePath, jsonData) => writeString(filePath, JSON.stringify(jsonData));\n  \/**\n   * @param {string} filePath\n   * @param {Image} image\n   *\/\n  const writeImage = (filePath, image) => {\n    const nextPath = safePath(filePath);\n    preWrite(nextPath);\n    return fm.writeImage(nextPath, image)\n  };\n\n  const readString = (filePath) => {\n    return fm.readString(\n      fm.joinPath(cacheDirectory, filePath)\n    )\n  };\n\n  const readJSON = (filePath) => JSON.parse(readString(filePath));\n  \/**\n   * @param {string} filePath\n   *\/\n  const readImage = (filePath) => {\n    return fm.readImage(fm.joinPath(cacheDirectory, filePath))\n  };\n\n  return {\n    cacheDirectory,\n    writeString,\n    writeJSON,\n    writeImage,\n    readString,\n    readJSON,\n    readImage\n  }\n};\n\n\/**\n * @param {string} data\n *\/\nconst hashCode = (data) => {\n  return Array.from(data).reduce((accumulator, currentChar) => Math.imul(31, accumulator) + currentChar.charCodeAt(0), 0)\n};\n\nconst useCache = (useICloud) => {\n  const fm = FileManager[useICloud ? 'iCloud' : 'local']();\n  const cacheDirectory = fm.joinPath(fm.documentsDirectory(), Script.name());\n\n  const writeString = (filePath, content) => {\n    const safePath = fm.joinPath(cacheDirectory, filePath).replace(\/\\\/+$\/, '');\n    const i = safePath.lastIndexOf('\/');\n    const directory = safePath.substring(0, i);\n    if (!fm.fileExists(directory)) {\n      fm.createDirectory(directory, true);\n    }\n    fm.writeString(safePath, content);\n  };\n\n  const writeJSON = (filePath, jsonData) => writeString(filePath, JSON.stringify(jsonData));\n\n  const readString = (filePath) => {\n    return fm.readString(\n      fm.joinPath(cacheDirectory, filePath)\n    )\n  };\n\n  const readJSON = (filePath) => JSON.parse(readString(filePath));\n\n  return {\n    cacheDirectory,\n    writeString,\n    writeJSON,\n    readString,\n    readJSON\n  }\n};\n\nconst readSettings = async () => {\n  const localFM = useCache();\n  let settings = localFM.readJSON('settings.json');\n  if (settings) {\n    console.log('[info] use local settings');\n    return settings\n  }\n\n  const iCloudFM = useCache(true);\n  settings = iCloudFM.readJSON('settings.json');\n  if (settings) {\n    console.log('[info] use iCloud settings');\n  }\n  return settings\n};\n\nconst writeSettings = async (data, { useICloud }) => {\n  const fm = useCache(useICloud);\n  fm.writeJSON('settings.json', data);\n};\n\nconst removeSettings = async (settings) => {\n  const cache = useCache(settings.useICloud);\n  FileManager.local().remove(\n    FileManager.local().joinPath(\n      cache.cacheDirectory,\n      'settings.json'\n    )\n  );\n};\n\nconst moveSettings = (useICloud, data) => {\n  const localFM = useCache();\n  const iCloudFM = useCache(true);\n  const [i, l] = [\n    FileManager.local().joinPath(\n      iCloudFM.cacheDirectory,\n      'settings.json'\n    ),\n    FileManager.local().joinPath(\n      localFM.cacheDirectory,\n      'settings.json'\n    )\n  ];\n  try {\n    writeSettings(data, { useICloud });\n    if (useICloud) {\n      FileManager.local().remove(l);\n    } else {\n      FileManager.iCloud().remove(i);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n};\n\n\/**\n * @param {object} options\n * @param {{\n *  name: string;\n *  label: string;\n *  type: string;\n *  default: unknow;\n * }[]} options.formItems\n * @param {(data: {\n *  settings: Record<string, string>;\n *  family: string;\n * }) => Promise<ListWidget>} options.render\n * @param {string} [options.homePage]\n *\/\nconst withSettings = async (options = {}) => {\n  const {\n    formItems = [],\n    render,\n    homePage = 'https:\/\/www.imarkr.com'\n  } = options;\n\n  let settings = await readSettings() || {};\n\n  if (config.runsInWidget) {\n    const widget = await render({ settings });\n    return widget\n  }\n\n  \/\/ ====== web start =======\n  const style =\n`:root {\n  --color-primary: #007aff;\n  --divider-color: rgba(60,60,67,0.36);\n  --card-background: #fff;\n  --card-radius: 10px;\n  --list-header-color: rgba(60,60,67,0.6);\n}\n* {\n  -webkit-user-select: none;\n  user-select: none;\n}\nbody {\n  margin: 10px 0;\n  -webkit-font-smoothing: antialiased;\n  font-family: \"SF Pro Display\",\"SF Pro Icons\",\"Helvetica Neue\",\"Helvetica\",\"Arial\",sans-serif;\n  accent-color: var(--color-primary);\n}\ninput {\n  -webkit-user-select: auto;\n  user-select: auto;\n}\nbody {\n  background: #f2f2f7;\n}\nbutton {\n  font-size: 16px;\n  background: var(--color-primary);\n  color: #fff;\n  border-radius: 8px;\n  border: none;\n  padding: 0.24em 0.5em;\n}\nbutton .iconfont {\n  margin-right: 6px;\n}\n.list {\n  margin: 15px;\n}\n.list__header {\n  margin: 0 20px;\n  color: var(--list-header-color);\n  font-size: 13px;\n}\n.list__body {\n  margin-top: 10px;\n  background: var(--card-background);\n  border-radius: var(--card-radius);\n  border-radius: 12px;\n  overflow: hidden;\n}\n.form-item {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-size: 16px;\n  min-height: 2em;\n  padding: 0.5em 20px;\n  position: relative;\n}\n.form-item--link .icon-arrow_right {\n  color: #86868b;\n}\n.form-item + .form-item::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 20px;\n  right: 0;\n  border-top: 0.5px solid var(--divider-color);\n}\n.form-item .iconfont {\n  margin-right: 4px;\n}\n.form-item input,\n.form-item select {\n  font-size: 14px;\n  text-align: right;\n}\n.form-item input[type=\"checkbox\"] {\n  width: 1.25em;\n  height: 1.25em;\n}\ninput[type=\"number\"] {\n  width: 4em;\n}\ninput[type='checkbox'][role='switch'] {\n  position: relative;\n  display: inline-block;\n  appearance: none;\n  width: 40px;\n  height: 24px;\n  border-radius: 24px;\n  background: #ccc;\n  transition: 0.3s ease-in-out;\n}\ninput[type='checkbox'][role='switch']::before {\n  content: '';\n  position: absolute;\n  left: 2px;\n  top: 2px;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background: #fff;\n  transition: 0.3s ease-in-out;\n}\ninput[type='checkbox'][role='switch']:checked {\n  background: var(--color-primary);\n}\ninput[type='checkbox'][role='switch']:checked::before {\n  transform: translateX(16px);\n}\n.actions {\n  margin: 15px;\n}\n.copyright {\n  margin: 15px;\n  font-size: 12px;\n  color: #86868b;\n}\n.copyright a {\n  color: #515154;\n  text-decoration: none;\n}\n.preview.loading {\n  pointer-events: none;\n}\n.icon-loading {\n  display: inline-block;\n  animation: 1s linear infinite spin;\n}\n@keyframes spin {\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(1turn);\n  }\n}\n@media (prefers-color-scheme: dark) {\n  :root {\n    --divider-color: rgba(84,84,88,0.65);\n    --card-background: #1c1c1e;\n    --list-header-color: rgba(235,235,245,0.6);\n  }\n  body {\n    background: #000;\n    color: #fff;\n  }\n}`;\n\n  const js =\n`(() => {\n  const settings = JSON.parse('${JSON.stringify(settings)}')\n  const formItems = JSON.parse('${JSON.stringify(formItems)}')\n  \n  window.invoke = (code, data) => {\n    window.dispatchEvent(\n      new CustomEvent(\n        'JBridge',\n        { detail: { code, data } }\n      )\n    )\n  }\n  \n  const iCloudInput = document.querySelector('input[name=\"useICloud\"]')\n  iCloudInput.checked = settings.useICloud\n  iCloudInput\n    .addEventListener('change', (e) => {\n      invoke('moveSettings', e.target.checked)\n    })\n  \n  const formData = {};\n\n  const fragment = document.createDocumentFragment()\n  for (const item of formItems) {\n    const value = settings[item.name] ?? item.default ?? null\n    formData[item.name] = value;\n    const label = document.createElement(\"label\");\n    label.className = \"form-item\";\n    const div = document.createElement(\"div\");\n    div.innerText = item.label;\n    label.appendChild(div);\n    if (item.type === 'select') {\n      const select = document.createElement('select')\n      select.className = 'form-item__input'\n      select.name = item.name\n      select.value = value\n      for (const opt of (item.options || [])) {\n        const option = document.createElement('option')\n        option.value = opt.value\n        option.innerText = opt.label\n        option.selected = value === opt.value\n        select.appendChild(option)\n      }\n      select.addEventListener('change', (e) => {\n        formData[item.name] = e.target.value\n        invoke('changeSettings', formData)\n      })\n      label.appendChild(select)\n    } else {\n      const input = document.createElement(\"input\")\n      input.className = 'form-item__input'\n      input.name = item.name\n      input.type = item.type || \"text\";\n      input.enterKeyHint = 'done'\n      input.value = value\n      \/\/ Switch\n      if (item.type === 'switch') {\n        input.type = 'checkbox'\n        input.role = 'switch'\n        input.checked = value\n      }\n      if (item.type === 'number') {\n        input.inputMode = 'decimal'\n      }\n      if (input.type === 'text') {\n        input.size = 12\n      }\n      input.addEventListener(\"change\", (e) => {\n        formData[item.name] =\n          item.type === 'switch'\n          ? e.target.checked\n          : item.type === 'number'\n          ? Number(e.target.value)\n          : e.target.value;\n        invoke('changeSettings', formData)\n      });\n      label.appendChild(input);\n    }\n    fragment.appendChild(label);\n  }\n  document.getElementById('form').appendChild(fragment)\n\n  for (const btn of document.querySelectorAll('.preview')) {\n    btn.addEventListener('click', (e) => {\n      const target = e.currentTarget\n      target.classList.add('loading')\n      const icon = e.currentTarget.querySelector('.iconfont')\n      const className = icon.className\n      icon.className = 'iconfont icon-loading'\n      const listener = (event) => {\n        const { code } = event.detail\n        if (code === 'previewStart') {\n          target.classList.remove('loading')\n          icon.className = className\n          window.removeEventListener('JWeb', listener);\n        }\n      }\n      window.addEventListener('JWeb', listener)\n      invoke('preview', e.currentTarget.dataset.size)\n    })\n  }\n\n  const reset = () => {\n    for (const item of formItems) {\n      const el = document.querySelector(\\`.form-item__input[name=\"\\${item.name}\"]\\`)\n      formData[item.name] = item.default\n      if (item.type === 'switch') {\n        el.checked = item.default\n      } else {\n        el.value = item.default\n      }\n    }\n    invoke('removeSettings', formData)\n  }\n  document.getElementById('reset').addEventListener('click', () => reset())\n})()`;\n\n  const html =\n`<html>\n  <head>\n    <meta name='viewport' content='width=device-width, user-scalable=no'>\n    <link rel=\"stylesheet\" href=\"\/\/at.alicdn.com\/t\/c\/font_3772663_kmo790s3yfq.css\" type=\"text\/css\">\n    <style>${style}<\/style>\n  <\/head>\n  <body>\n  <div class=\"list\">\n    <div class=\"list__header\">一般<\/div>\n    <form class=\"list__body\" action=\"javascript:void(0);\">\n      <label class=\"form-item\">\n        <div>iCloud 同步<\/div>\n        <input name=\"useICloud\" type=\"checkbox\" role=\"switch\">\n      <\/label>\n      <label id='reset' class=\"form-item form-item--link\">\n        <div>恢复默认<\/div>\n        <i class=\"iconfont icon-arrow_right\"><\/i>\n      <\/label>\n    <\/form>\n  <\/div>\n  <div class=\"list\">\n    <div class=\"list__header\">设置<\/div>\n    <form id=\"form\" class=\"list__body\" action=\"javascript:void(0);\"><\/form>\n  <\/div>\n  <div class=\"actions\">\n    <button class=\"preview\" data-size=\"small\"><i class=\"iconfont icon-yingyongzhongxin\"><\/i>小组件<\/button>\n    <button class=\"preview\" data-size=\"medium\"><i class=\"iconfont icon-daliebiao\"><\/i>中组件<\/button>\n    <button class=\"preview\" data-size=\"large\"><i class=\"iconfont icon-dantupailie\"><\/i>大组件<\/button>\n  <\/div>\n  <footer>\n    <div class=\"copyright\">Copyright © 2022 <a href=\"javascript:invoke('safari','https:\/\/www.imarkr.com');\">iMarkr<\/a> All rights reserved.<\/div>\n  <\/footer>\n    <script>${js}<\/script>\n  <\/body>\n<\/html>`;\n\n  const webView = new WebView();\n  await webView.loadHTML(html, homePage);\n\n  const injectListener = async () => {\n    const event = await webView.evaluateJavaScript(\n      `(() => {\n        const controller = new AbortController()\n        const listener = (e) => {\n          completion(e.detail)\n          controller.abort()\n        }\n        window.addEventListener(\n          'JBridge',\n          listener,\n          { signal: controller.signal }\n        )\n      })()`,\n      true\n    ).catch((err) => {\n      console.error(err);\n      throw err\n    });\n    const { code, data } = event;\n    switch (code) {\n      case 'preview': {\n        const widget = await render({ settings, family: data });\n        webView.evaluateJavaScript(\n          'window.dispatchEvent(new CustomEvent(\\'JWeb\\', { detail: { code: \\'previewStart\\' } }))',\n          false\n        );\n        widget[`present${data.replace(data[0], data[0].toUpperCase())}`]();\n        break\n      }\n      case 'safari':\n        Safari.openInApp(data, true);\n        break\n      case 'changeSettings':\n        settings = { ...settings, ...data };\n        writeSettings(data, { useICloud: settings.useICloud });\n        break\n      case 'moveSettings':\n        settings.useICloud = data;\n        moveSettings(data, settings);\n        break\n      case 'removeSettings':\n        settings = { ...settings, ...data };\n        removeSettings(settings);\n        break\n    }\n    injectListener();\n  };\n\n  injectListener();\n  webView.present();\n  \/\/ ======= web end =========\n};\n\n\/**\n * 是否缓存请求响应数据\n *\n * - `true`：网络异常时显示历史缓存数据\n * - `false`：当网络异常时组件会显示红色异常信息\n *\/\nlet cacheData = true;\nconst API_BASE = 'https:\/\/api.coingecko.com\/api\/v3';\nconst cache = useCache$1();\n\nconst fetchCoinList = async () => {\n  if (!config.runsInApp) {\n    try {\n      const list = cache.readJSON('coins-list.json');\n      if (list && list.length) {\n        return list\n      }\n    } catch (e) {}\n  }\n  const url = `${API_BASE}\/coins\/list`;\n  const request = new Request(url);\n  const json = await request.loadJSON();\n  cache.writeJSON('coins-list.json', json);\n  return json\n};\n\nconst findCoins = async (symbols) => {\n  const list = await fetchCoinList();\n  const result = [];\n  for (const symbol of symbols) {\n    const coin = list.find((item) => item.symbol.toLowerCase() === symbol.toLowerCase());\n    result.push(coin);\n  }\n  return result\n};\n\nconst fetchMarkets = async (params = {}) => {\n  const query =\n   Object.entries({\n     vs_currency: 'USD',\n     ...params\n   })\n     .map(([k, v]) => `${k}=${v || ''}`)\n     .join('&');\n  const url = `${API_BASE}\/coins\/markets?${query}`;\n  const request = new Request(url);\n  try {\n    const json = await request.loadJSON();\n    if (cacheData) {\n      cache.writeJSON('data.json', json);\n    }\n    return json\n  } catch (e) {\n    if (cacheData) {\n      return cache.readJSON('data.json')\n    }\n    throw e\n  }\n};\n\n\/**\n * @param {string} url\n * @returns {Image}\n *\/\nconst getIcon = async (url) => {\n  const hash = `${hashCode(url)}`;\n  try {\n    const icon = cache.readImage(hash);\n    if (!icon) {\n      throw new Error('no cached icon')\n    }\n    return icon\n  } catch (e) {\n    const icon = await getImage(url);\n    cache.writeImage(hash, icon);\n    return icon\n  }\n};\n\nconst getSmallBg = async (url) => {\n  const webview = new WebView();\n  const js =\n    `const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => {\n      const { width, height } = img\n      canvas.width = width\n      canvas.height = height\n      ctx.globalAlpha = 0.3\n      ctx.drawImage(\n        img,\n        -width \/ 2 + 50,\n        -height \/ 2 + 50,\n        width,\n        height\n      )\n      const uri = canvas.toDataURL()\n      completion(uri);\n    };\n    img.src = '${url}'`;\n  const uri = await webview.evaluateJavaScript(js, true);\n  const base64str = uri.replace(\/^data:image\\\/\\w+;base64,\/, '');\n  const image = Image.fromData(Data.fromBase64String(base64str));\n  return image\n};\n\nconst addListItem = async (widget, market) => {\n  const item = widget.addStack();\n  item.url = `https:\/\/www.coingecko.com\/${Device.language()}\/coins\/${market.id}`;\n  const left = item.addStack();\n  left.centerAlignContent();\n  const image = left.addImage(await getIcon(market.image));\n  image.imageSize = new Size(28, 28);\n  left.addSpacer(8);\n  const coin = left.addStack();\n  coin.layoutVertically();\n  const symbol = coin.addText(market.symbol.toUpperCase());\n  symbol.font = Font.semiboldSystemFont(16);\n  const name = coin.addText(market.name);\n  name.font = Font.systemFont(10);\n  name.textColor = Color.gray();\n\n  const right = item.addStack();\n  const price = right.addStack();\n  price.layoutVertically();\n  price.centerAlignContent();\n  const cuWrap = price.addStack();\n  cuWrap.addSpacer();\n  const currency = cuWrap.addText(`$ ${market.current_price}`);\n  currency.font = Font.semiboldSystemFont(15);\n  const timeWrap = price.addStack();\n  timeWrap.addSpacer();\n  const dfm = new DateFormatter();\n  dfm.dateFormat = 'hh:mm';\n  const time = timeWrap.addText(dfm.string(new Date(market.last_updated)));\n  time.font = Font.systemFont(10);\n  time.textColor = Color.gray();\n  right.addSpacer(8);\n  const perWrap = right.addStack();\n  perWrap.size = new Size(72, 28);\n  perWrap.cornerRadius = 4;\n  const per = market.price_change_percentage_24h;\n  perWrap.backgroundColor = per > 0 ? Color.green() : Color.red();\n  perWrap.centerAlignContent();\n  const percent = perWrap.addText(`${per > 0 ? '+' : ''}${per.toFixed(2)}%`);\n  percent.font = Font.semiboldSystemFont(14);\n  percent.textColor = Color.white();\n  percent.lineLimit = 1;\n  percent.minimumScaleFactor = 0.1;\n};\n\nconst addList = async (widget, data) => {\n  widget.url = `https:\/\/www.coingecko.com\/${Device.language()}`;\n  widget.setPadding(5, 15, 5, 15);\n  await Promise.all(\n    data.map((item) => {\n      const add = async () => {\n        widget.addSpacer();\n        await addListItem(widget, item);\n      };\n      return add()\n    })\n  );\n  widget.addSpacer();\n};\n\nconst render = async (data) => {\n  const market = data[0];\n  const widget = new ListWidget();\n  widget.backgroundColor = Color.dynamic(new Color('#fff'), new Color('#282828'));\n  if (config.widgetFamily === 'small') {\n    widget.url = `https:\/\/www.coingecko.com\/${Device.language()}\/coins\/${market.id}`;\n    const image = await getIcon(market.image);\n    const obase64str = Data.fromPNG(image).toBase64String();\n    widget.backgroundColor = Color.dynamic(new Color('#fff'), new Color('#282828'));\n    const bg = await getSmallBg(`data:image\/png;base64,${obase64str}`);\n    widget.backgroundImage = bg;\n    widget.setPadding(12, 12, 12, 12);\n    const coin = widget.addText(market.symbol.toUpperCase());\n    coin.font = Font.heavySystemFont(24);\n    coin.rightAlignText();\n    const name = widget.addText(market.name);\n    name.font = Font.systemFont(10);\n    name.textColor = Color.gray();\n    name.rightAlignText();\n    widget.addSpacer();\n\n    const changePercent = market.price_change_percentage_24h || NaN;\n    const trend = widget.addText(`${changePercent > 0 ? '+' : ''}${changePercent.toFixed(2)}%`);\n    trend.font = Font.semiboldSystemFont(16);\n    trend.textColor = changePercent >= 0 ? Color.green() : Color.red();\n    trend.rightAlignText();\n\n    const price = widget.addText(`$ ${market.current_price}`);\n    price.font = Font.boldSystemFont(28);\n    price.rightAlignText();\n    price.lineLimit = 1;\n    price.minimumScaleFactor = 0.1;\n    const history = widget.addText(`H: ${market.high_24h}, L: ${market.low_24h}`);\n    history.font = Font.systemFont(10);\n    history.textColor = Color.gray();\n    history.rightAlignText();\n    history.lineLimit = 1;\n    history.minimumScaleFactor = 0.1;\n  } else if (config.widgetFamily === 'medium') {\n    await addList(widget, data.slice(0, 3));\n  } else if (config.widgetFamily === 'large') {\n    await addList(widget, data.slice(0, 6));\n  }\n\n  return widget\n};\n\nconst main = async () => {\n  const [symbols] = (args.widgetParameter || '').split(';').map((item) => item.trim());\n\n  \/\/ symbols = 'btc,eth'\n  let ids = '';\n  if (symbols) {\n    const list = await findCoins(\n      symbols.split(',').map((item) => item.trim())\n    );\n    ids = list.filter((item) => item)\n      .map((item) => item.id)\n      .join(',');\n  }\n\n  const widget = await withSettings({\n    formItems: [\n      {\n        name: 'cacheData',\n        type: 'switch',\n        label: '缓存数据',\n        default: true\n      }\n    ],\n    render: async ({ settings, family }) => {\n      config.widgetFamily = family ?? config.widgetFamily;\n      cacheData = settings.cacheData ?? cacheData;\n\n      const markets = await fetchMarkets({ ids });\n      const widget = await render(markets);\n      return widget\n    }\n  });\n  if (config.runsInWidget) {\n    Script.setWidget(widget);\n  }\n};\n\nawait main();\n",
  "share_sheet_inputs" : [

  ]
}